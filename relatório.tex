%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}

\usepackage{url}
%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}
%
%\lstset{ %
%	language=C,								% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\def\darius{\textsf{Darius}\xspace}
\def\java{\texttt{Java}\xspace}

\title{Processamento de Linguagens\\ (3º ano de Licenciatura em Engenharia Informática)\\ \textbf{Trabalho Prático 1}\\ Relatório de Desenvolvimento}
\author{André Geralades (67673) \and Patrícia Barros (67665) \and Sandra Ferreira (67709)}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este relatório descreve todo o processo de desenvolvimento e decisões tomadas para a realização do segundo trabalho prático da Unidade Curricular de Processamento de Linguagens.\\ O problema a resolver consiste na criação de uma linguagem imperativa simples e da respetiva \textbf{GIC} seguida do desenvolvimento de um compilador para a mesma que gera pseudo-código \textit{Assembly}.

\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}


A resolução deste trabalho prático passa pelo desenvolvimento de um Filtro de Texto em Flex para gerar ficheiros em HTML. Para isso utilizamos as técnicas leccionadas nas aulas da Unidade Curricular de Processamento de Linguagens. Pretendemos portanto com este trabalho aprimorar as nossas capacidades de escrever \emph{Expressões Regulares (ER)} e também a nossa experiência na utilização da linguagem de programação C.\\ Neste relatório apresentamos todos os passos e decisões tomadas durante todo o processo, descrevemos as estruturas criadas para guardar o texto extraído pelo filtro e também uma apresentação do produto final (em HTML) obtido com a utilização do filtro criado por nós.


\section*{Estrutura do Relatório} \label{estrutura}
A elaboração deste documento teve por base a estrutura do relatório fornecida pelo docente. \\
O relatório encontra-se então estruturado da seguinte forma: possuí um primeiro capítulo que faz uma contextualização ao assunto tratado neste trabalho, seguindo-se uma introdução onde são apresentadas as metas de aprendizagem pertendidas.\\
Posteriormente é exposto o tema escolhido para desenvolver o trabalho e as tarefas que nele estão envolvidas.\\
Imediatamente após, são exibidas as expressões regulares definidas para extrair do ficheiro XML as informações para a construção da página HTML, mostrando também os estados da aplicação e os módulos desta.\\
Não menos importante, seguem-se os capitulos de apresentação das estruturas de dados usadas no desenvolvimento do trabalho e dos testes realizados à aplicação com os devidos resultados.
Por último, faz-se uma análise crítica relativa quer ao desenvolvimento do projeto quer ao seu estado final e ainda é feita uma abordagem ao trabalho futuro.

\chapter{Análise e Especificação} \label{ae}
\section{Enunciado}
Pretende-se que comece por definir uma linguagem de programação interativa simples (\textbf{LPIS}), a seu gosto.\\
Apenas deve ter em consideração que a \textbf{LPIS} terá de permitir manusear variáveis do tipo inteiro (escalar ou \textit{array}) e realizar as operações básicas como atribuições de expressões a variáveis, ler do \textit{standard input} e escrever no \textit{standard output}. As instruções vulgares para controlo de fluxo de execução - \textit{condicional} e \textit{cíclica}- devem estar também previstas.\\
Sobre inteiros, estão disponíveis as habituais operações aritméticas, relacionais e lógicas, bem como operação de indexação sobre \textit{arrays}.\\
Como é da praxe neste tipo de linguagens, as nossas variáveis deverão ser declaradas no inicio do programa e não pode haver re-declarações, nem utilizações sem declaração prévia; se nada for explicitado, o valor da variável após a declaração é indefinido.\\
Desenvolva, então, um compilador para a \textbf{LPIS}, com base na \textbf{GIC} criada acima e recurso ao Gerador \textbf{Yacc/Flex} ou \textbf{AnTLR}.\\
O compilador da \textbf{LPIS} deve gerar \textbf{pseudo-código}, Assembly da Máquina Virtual VM cuja documentação completa será disponibilizada no Bb.

\section{Descrição do Problema}
Como descrito na secção anterior o desafio que nos foi proposto consiste na criação de uma linguagem imperativa simples apenas com as características mais básicas, o desenvolvimento de uma \textbf{GIC} para a mesma e ainda a criação de um compilador gerador de \textbf{pseudo-código} Assembly. \\
Posto isto tivemos então de, primeiramente, pensar e desenhar uma linguagem imperativa ao nosso gosto, seguindo os requisitos pedidos. De seguida foi necessário criarmos uma gramática que a descrevesse e, finalmente, com recurso a essa gramática, tornar possível o armazenamento dos dados vindos de um programa escrito na nossa linguagem necessários à geração do \textbf{pseudo-código} Assembly.

\chapter{Concepção/desenho da Resolução}\label{concepcao}
Nos próximos capítulos iremos descrever todas as decisões tomadas no decorrer deste trabalho.

\section{Desenho da Linguagem}
O principal princípio que seguimos aquando de decidir as caraterísticas da nossa linguagem foi a simplicidade desta, desenhando-a de forma a que os passos seguintes do trabalho não fossem excessivamente complicados. Posto isto, decidimos que a nossa linguagem suportaria apenas os requisitos definidos no enunciado.\\
Concluímos que nos seria útil que qualquer programa da nossa linguagem estivesse dividido em duas partes: as declarações de variáveis e o corpo, constituído por instruções. Percebemos também que seria mais fácil se tanto a operação condicional como o ciclo tivessem sempre marcadores do seu início e fim, e escolhemos neste caso usar como marcadores palavras reservadas para os delimitarem.\\
 Assim, um programa tem \textbf{obrigatoriamente} de iniciar com a palavra reservada \textbf{BEGIN} e fazer-se seguir de uma ou muitas declarações de variáveis (nunca poderá haver um programa sem nenhuma declaração pois consideramos que um programa sem variáveis não faz sentido), declarações estas que são constituídas por um tipo e uma ou mais variáveis (palavras) separadas por vírgulas. No caso de ser um \textit{array} terá também de ser declarado o seu tamanho (um número entre parenteses colocado logo a seguir ao tipo). Cada declaração termina obrigatoriamente com um \textbf{;}. Os tipos das variáveis são palavras reservadas, podendo ser \textbf{INT} ou \textbf{ARRAY}.\\
Após terminadas as declarações damos então início ao corpo do programa, através da palavra reservada \textbf{BODY}.\\
O corpo do programa é constituído por uma ou mais instruções (mais uma vez, também o corpo não pode ser vazio pois achamos que isso não faria sentido). Cada instrução pode ser de um de cinco tipos diferentes: atribuição, condição, ciclo, escrita ou leitura e termina sempre com um ponto e vírgula.\\
Uma atribuição consiste numa variável seguida de um sinal de igual que precede uma expressão. Neste caso uma variável pode ser uma palavra ou uma palavra seguida de uma expressão entre parênteses (para a operação de indexação de um \textit{array}). Por sua vez uma expressão é um termo ou uma expressão seguida de um operador de adição que precede um termo, sendo que um termo é um fator ou um termo seguido de um operador multiplicativo que precede um fator. Um fator pode ser uma palavra, um número ou uma condição entre parênteses, sendo que uma condição neste caso é uma expressão ou duas expressões separadas por um operador relacional.\\
Uma condição é sempre iniciada pela palavra reservada \textbf{IF} que precede uma ou várias instruções e pode ou não ser seguida da palavra reservada \textbf{ELSE} seguida de mais instruções. Uma condição termina sempre com a palavra reservada \textbf{ENDIF}.\\
Um ciclo é sempre iniciado pela palavra reservada \textbf{WHILE} seguida de uma condição entre parênteses que precede uma ou mais instruções e termina sempre com a palavra reservada \textbf{ENDWHILE}.
As instruções de leitura escrita são representadas por duas palavras reservadas: \textbf{READ} e \textbf{WRITE} respetivamente. No caso da leitura a palavra reservada segue-se de uma variável (inteira ou a posição de um \textit{array}) entre parênteses, e no caso da escrita segue-se de uma expressão entre parênteses.\\
Os símbolos que utilizamos para os operadores aditivos, multiplicativos e relacionais são os seguintes:
\begin{verbatim}
opA 		"+"|"-"|"||"     
opM			"&&"|"*"|"/"
opR			">>"|"<<"|">="|"<="|"=="|"|=|"
\end{verbatim}
Para melhor compreensão da descrição acima segue-se um exemplo de um programa simples escrito na nossa linguagem.
\begin{lstlisting}[language=C]
BEGIN
INT x,y,y;
ARRAY(100) vect , vects;
BODY
x=1;
y=1+2;
IF (x>>5) y=y+1; ENDIF;
x=2;
WHILE (y<<2) y=y+1; IF (x>>5) w=y+1; ENDIF; ENDWHILE;
IF (x==1) y=y+1; y=2; ELSE y=3; ENDIF;
END
\end{lstlisting}

\section{Desenho da Gramática}
Após desenhada e descrita a linguagem imperativa que iremos usar, resta transformar todas as regras que definimos sobre ela numa \textbf{GIC}.\\
Os símbolos não-terminais da gramática que definimos são os seguintes: programa, desclaracoes, declaracao, tipo, variaveis, variavel instrucoes, instrucao, atribuicao, var, expressao, termo, fator, condicao, ciclo e cond.\\
Por sua vez os símbolo terminais são: num, pal, IF, ENDIF, WHILE, ENDWHILE, BEGINP, MIDDLE, ENDP, INT, ARRAY, OPM, OPR, OPA, ";", ",", "(",")" e "=". \\
Na concepção da nossa gramática utilizamos em todos os casos recursividade à esquerda.
Segue-se então a gramática gerada:
\begin{lstlisting}[language=C]
programa	:	BEGINP		

declaracoes	: declaracao 
| declaracoes  declaracao 
;

declaracao	: tipo variaveis ';'					
| tipo '(' num ')' variaveis ';'	
;	

tipo		: INT 							
| ARRAY							
;

variaveis	:	variavel 					
|	variaveis ',' variavel	
;

variavel 	:	pal 					 							
;

instrucoes	:	instrucao ';'		
|	instrucoes  instrucao ';'
;

instrucao	:	atribuicao
| 	condicao
| 	ciclo
|	READ '(' var ')' 
|	WRITE '('expressao')' 
;

atribuicao 	:	var '=' expressao 				
;

var 		: 	pal 					
| 	pal '('expressao')'
;

expressao	: 	termo
| 	expressao OPA termo
;

termo		: 	fator
| 	termo OPM fator
;

fator		: 	var 						
| 	num
|	'(' cond ')'
;

condicao	: 	IF '('cond')' instrucoes  ENDIF 
| 	IF '('cond')' instrucoes  ELSE instrucoes ENDIF	
;

ciclo 		:	WHILE '('cond')' instrucoes ENDWHILE
;

cond		:	expressao
| 	expressao OPR expressao
;
\end{lstlisting}

\section{Módulos da Aplicação}
\textbf{makefile} Ficheiro com a configuração de compilação.\\
\textbf{tp2.l} Ficheiro com código de um analisador léxico que serve de suporte à nossa gramática. \\
\textbf{tp2.y} Ficheiro que contém o código \textbf{YACC} correspondente à nossa gramática e inclui nesta o código necessário para a geração do código Assembly resultante. \\
\textbf{arvore.c} Ficheiro onde se encontra o código da estrutura definida para guardar as informações das variáveis encontradas no programa. \\
\textbf{arvore.h} Ficheiro com a estrutura definida para guardar informações das variáveis e com as assinaturas das funções definidas no arvore.c.

\section{Estruturas de Dados}
Para guardar as informações relativas às variáveis que se encontram nos programas escritos na nossa linguagem foi necessário criar uma estrutura. \\
A estrutura mais apropriada para este efeito é uma Tabela de Hash devido a ser mais eficiente a procura por \textit{strings}, no entanto, devido à nossa inexperiência em trabalhar com esse tipo de estrutura, optamos por utilizar uma Árvore Binária de Procura, com a qual estamos mais familiarizados, para este efeito.\\
Foi necessário guardar, para cada variável declarada, o seu nome, tipo, registo e tamanho. \\
Decidimos que o tamanho seria 1 para todas as variáveis de tipo inteiro, ficando os \textit{arrays} com o tamanho definido aquando da declaração.\\
O valor do registo é sequencial, ou seja, existe uma variável global inteira que é incrementada de cada vez que uma variável é declarada. No caso dessa variável ser um \textit{array} o valor do registo é incrementado tantas vezes quanto o tamanho do \textit{array}.\\
Segue-se o código referente à declaração da estrutura que utilizamos para guardar estas informações:

\begin{lstlisting}[language=C]
typedef struct node {
char* nome;
char* tipo;
int tamanho;
int registo;
struct node *esq;
struct node *dir;
} Node, *Tree;
\end{lstlisting}



\chapter{Testes realizados e Resultados}\label{testes}




\chapter{Conclusão} \label{concl}

\appendix
\chapter{Código Flex}
\lstinputlisting{tp2.l} 
\iffalse
\chapter{Código Yacc}
\lstinputlisting{tp2.y}
\chapter{Código da Árvore Binária}
\lstinputlisting{arvore.c}
\fi










\end{document} 